import os 
from dotenv import load_dotenv
load_dotenv()
from fastapi import APIRouter, Header, HTTPException, BackgroundTasks, Request
from pydantic import BaseModel, ValidationError
from typing import List, Optional
import httpx
import logging
import json # Import json for printing

# Import our modules
from honeypot.AI import analyze_and_reply
from honeypot.utils import extract_intelligence
from honeypot.store import get_or_create_session, update_session

router = APIRouter()
logger = logging.getLogger("uvicorn")

# --- Models (Keep these for manual validation) ---
class MessageDetail(BaseModel):
    sender: str
    text: str
    timestamp: str

class Metadata(BaseModel):
    channel: Optional[str] = None
    language: Optional[str] = None # Added potential missing field
    locale: Optional[str] = None   # Added potential missing field

class ScamRequest(BaseModel):
    sessionId: str
    message: MessageDetail
    conversationHistory: Optional[List[MessageDetail]] = [] # Made Optional just in case
    metadata: Optional[Metadata] = None

# --- Callback Function (Same as before) ---
async def send_final_report(payload: dict):
    url = "https://hackathon.guvi.in/api/updateHoneyPotFinalResult"
    async with httpx.AsyncClient() as client:
        try:
            logger.info(f"ðŸš€ Sending Final Report for Session: {payload['sessionId']}")
            response = await client.post(url, json=payload, timeout=10.0)
            logger.info(f"âœ… Report Status: {response.status_code} | Body: {response.text}")
        except Exception as e:
            logger.error(f"âŒ Failed to report: {e}")

# --- UPDATED DEBUG ENDPOINT ---
@router.post("/chat")
async def chat_handler(request: Request, background_tasks: BackgroundTasks, x_api_key: str = Header(None)):
    
    # 1. READ RAW BODY (To debug the 422 error)
    try:
        raw_body = await request.json()
        print("\nðŸ” --- INCOMING DEBUG PAYLOAD --- ðŸ”")
        print(json.dumps(raw_body, indent=2))
        print("------------------------------------\n")
    except Exception as e:
        print(f"âŒ Could not parse JSON: {e}")
        raise HTTPException(status_code=400, detail="Invalid JSON")

    # 2. Manual Auth Check
    # (We do this after printing so we can see the payload even if auth fails, for debugging)
    if x_api_key != os.environ.get("API_KEY"):
        print(f"âŒ Auth Failed. Received Key: {x_api_key}")
        raise HTTPException(status_code=401, detail="Unauthorized")

    # 3. Manually Validate / Convert to Pydantic Model
    try:
        payload = ScamRequest(**raw_body)
    except ValidationError as e:
        print(f"âŒ PYDANTIC VALIDATION ERROR: {e}")
        # IMPORTANT: We return a fallback response so the Hackathon platform 
        # doesn't show 'Error!' even if our internal validation failed.
        return {
            "status": "success",
            "reply": "I received your message, but my internal validation failed. Check logs."
        }

    # --- FROM HERE, CODE IS NORMAL ---
    
    user_msg = payload.message.text
    session_id = payload.sessionId
    
    # State & Intelligence
    get_or_create_session(session_id)
    new_intel = extract_intelligence(user_msg)
    current_state = update_session(session_id, new_intel)

    # AI Processing
    # Ensure history is a list (if it came in as None)
    history = payload.conversationHistory if payload.conversationHistory else []
    ai_result = await analyze_and_reply(user_msg, history)
    
    current_state["totalMessagesExchanged"] += 1
    
    # Check Logic
    has_critical_info = (len(current_state["extractedIntelligence"]["upiIds"]) > 0 or 
                         len(current_state["extractedIntelligence"]["bankAccounts"]) > 0)
    is_long_conversation = current_state["totalMessagesExchanged"] >= 8
    
    if (has_critical_info or is_long_conversation) and not current_state["report_sent"]:
        final_payload = {
            "sessionId": session_id,
            "scamDetected": True,
            "totalMessagesExchanged": current_state["totalMessagesExchanged"],
            "extractedIntelligence": current_state["extractedIntelligence"],
            "agentNotes": "Auto-generated by HoneyPot AI"
        }
        background_tasks.add_task(send_final_report, final_payload)
        current_state["report_sent"] = True

    return {
        "status": "success",
        "reply": ai_result.get("reply", "...")
    }