import os
import logging
from fastapi import APIRouter, Header, BackgroundTasks, Request
from fastapi.responses import JSONResponse
import httpx

# Import your modules
from honeypot.AI import analyze_and_reply
from honeypot.utils import extract_intelligence
from honeypot.store import get_or_create_session, update_session

router = APIRouter()
logger = logging.getLogger("uvicorn")

# --- Callback Function ---
async def send_final_report(payload: dict):
    url = "https://hackathon.guvi.in/api/updateHoneyPotFinalResult"
    async with httpx.AsyncClient() as client:
        try:
            logger.info(f"ðŸš€ Sending Final Report for Session: {payload['sessionId']}")
            response = await client.post(url, json=payload, timeout=10.0)
            logger.info(f"âœ… Report Status: {response.status_code} | Body: {response.text}")
        except Exception as e:
            logger.error(f"âŒ Failed to report: {e}")

# --- ROBUST ENDPOINT (Manual Parsing like Friend's Code) ---
@router.post("/chat")
async def chat_handler(request: Request, background_tasks: BackgroundTasks):
    
    # 1. READ BODY MANUALLY (No Pydantic Validation Errors!)
    try:
        body = await request.json()
    except Exception:
        body = {}

    # 2. DEBUG LOGS
    print(f"\nðŸ“¥ INCOMING: {body}")

    # 3. MANUAL AUTH CHECK
    # We grab the header directly from the request object
    x_api_key = request.headers.get("x-api-key")
    valid_key = os.environ.get("API_KEY") 

    if valid_key and x_api_key != valid_key:
        print(f"âŒ Auth Failed. Received: {x_api_key}")
        # Return 401 JSON so the tester sees a clean error
        return JSONResponse(status_code=401, content={"detail": "Unauthorized"})

    # 4. SAFE EXTRACTION (Like Friend's Code)
    # Use .get() everywhere to prevent crashes
    session_id = body.get("sessionId", "unknown_session")
    
    # Handle 'message' safely (it might be a dict or missing)
    msg_obj = body.get("message", {})
    if isinstance(msg_obj, dict):
        user_msg = msg_obj.get("text", "")
    else:
        user_msg = str(msg_obj) # Handle case where message is just a string

    conversation_history = body.get("conversationHistory", [])
    if conversation_history is None:
        conversation_history = []

    # 5. HANDLE EMPTY PINGS (The Tester Check)
    if not user_msg:
        print("âœ… Detected Empty Ping. Returning Success.")
        return {"status": "success", "reply": "HoneyPot Active"}

    # --- REAL LOGIC STARTS HERE ---
    print(f"âœ… Processing Message: {user_msg}")

    # State & Intelligence
    get_or_create_session(session_id)
    new_intel = extract_intelligence(user_msg)
    current_state = update_session(session_id, new_intel)

    # AI Processing
    ai_result = await analyze_and_reply(user_msg, conversation_history)
    
    current_state["totalMessagesExchanged"] += 1
    
    # Check Logic for Reporting
    has_critical_info = (len(current_state["extractedIntelligence"]["upiIds"]) > 0 or 
                         len(current_state["extractedIntelligence"]["bankAccounts"]) > 0)
    is_long_conversation = current_state["totalMessagesExchanged"] >= 8
    
    if (has_critical_info or is_long_conversation) and not current_state["report_sent"]:
        final_payload = {
            "sessionId": session_id,
            "scamDetected": True,
            "totalMessagesExchanged": current_state["totalMessagesExchanged"],
            "extractedIntelligence": current_state["extractedIntelligence"],
            "agentNotes": "Auto-generated by HoneyPot AI"
        }
        background_tasks.add_task(send_final_report, final_payload)
        current_state["report_sent"] = True

    return {
        "status": "success",
        "reply": ai_result.get("reply", "...")
    }